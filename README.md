# foc
Two motor 48V 20+20A FOC controller for sim racing seatbelt tensioner

### Motor Selection
First, the correct motor type was selected based on requirements

While exhibiting drawbacks like cogging torque, BLDC PSMS was chosen for backdrivability and torque control. Specifically, the 48V model is chosen because of the lack of 220V main power in the room of operation.

Then correct torque and integrated sensors (Hall effect per phase and absolute encoder)

These are critical to this project because it involves operating the motor at low speeds and often from standstill, which the sensors improve the quality of the torque control.

After a great long search, a well priced high power model was found on AliBaba.

### Controller Build
The quest to develop a reasonably priced 2 channel 48V 40A FOC controller

I looked into existing solutions but found them to be too expensive, so I set out to make my own.

I learned a lot about Field oriented control and BLDC phases.

#### Controller Design Choices
- MCU: STMF405VGT, chosen for compatibilty with VESC firmware and high GPIO count, ADC for current sense
- Motor driver: 2x DRV8323S, no internal buck. High power LDO and additonal low noise LDO both already implemented. DRV8323S compatible with VESC via SPI, and internal current sense amplifiers
- MOFSET: 12x CSD19536KCS, high voltage, low RDS on, big thermally conductive package. Two for each phase: 2x3x2
- 6x Shunt resistors: Opting for higher quality control for the basis of FOC control: torque control by current measurement. One for each phase instead of Kirchoff's rule estimation for last one. In lower rpm scenarios like this one, two would be a noticable downgrade.
- Connections: USART, SWD, and USB all made avaliable and connected for debugging

Thus the following rough prototype was made:

<img width="377" alt="image" src="https://github.com/user-attachments/assets/0158843e-783a-4e0b-9bb7-46b238e166f8" />

![image](https://github.com/user-attachments/assets/02b2ee7c-641c-4e55-943c-85cce2903060)

Then, when I caclulated this in a few PCB manufactures, the cost was far more than just a prebuilt.
Parts alone rivaled prebuilt solutions on Alibaba, and the heavier copper layers and PCBA brought it to wild levels.

Unfourtanly, this meant I would have to opt for a prebuilt solution.

### Controller Selection

Of the existing solutions, the Odrive 3.6 stood out for meeting the requirements.

Unfortunately, it only has two shunt resistors where I would have prefered the full three. In theory the third's current can be calculated via kirchhoff's law but I'm not sure how much the inaccuracies will affect performance/smoothness.

This is also avaliable on Alibaba for far less than any other controller of its class.

### Case Design

While robust and powerful, these motors are not designed to withstand axial force (like that generated by the seatbelt resistance). In order to midigate this wear on the motors, and to mount them to the rig in the first place, a appropriate casing was designed.

Again not ideally, my 8020 rig has semiflat bottom profile, so only the top facing rail and the upper-most and bottom-most side rails are usable for mounting. I don't think expanding the mounts to the bottom one is necessary (the profile is quite tall).

<img width="564" alt="image" src="https://github.com/user-attachments/assets/8721395f-d786-44cd-a912-a3560354b6fa" />

Clamp like holders are implemented to fit the 70x70mm motor snugly. While the motor is about 150mm long, the last ~50mm is obstructed by cables, and regardless it hangs off the side of the rig.

Bearing inner axis and outer axis can be adjusted easily.

### Software and Control

Now with this overengineered hardware, a complementary control system is required.

The telemetry aggregator/effect generator will be SimHub (License will be needed to drive motion as well as 60fps)

While most DIY solutions use Arduinos with Simhub provided sketches, this adds unnessary complexity and latency. The most efficient solution is have the PC communicate directly to the on-board STM32F405.

Simhub, however, doesn't support this out of the box. (It does support custom serial devices, and so does ODrive. This means that plug-n-play would technically work, but Odrive's ASCII protocol is human readable text based, which is unnessary overhead and adds massive latency.)

Additionally, controlling ODrive native protocol from simhub's custom serial is impossible, since computing dynamic CRC and sequence number is not possible in SimHub command editor.

The solution here is to have Simhub (supported) output data to UDP, receieve that in script to then communicate to ODrive via native usb protocol (binary over serial).

In order to make full use of this hardware, road rumble (or other frequency effects) can also be implemented. In SimHub, the UDP output will be configured for N+2 axis, Torque right, Torque left, effect*n.

Then, mimicing simhub's own bassshaker driver method, frequency for each effect is determined by its amplitude. The script does this calculation per frame and drives the motor at this frequency and amplitude.

#### han.c design choices

- Asncy USB for minimal latency
- 1KHz control loop for rumble effects
- 2x (expandable) rumble effect combine
- Debug mode for latency debugging
- Precalculated CRC8/16 for Odrive native spec

Currently there can be up to 1ms where a new torque is recieved and when it is implemented. This will probably not matter.

This still uses the ODrive's CDC interface, which by default runs the ASCII protocol. This must be disabled.

#### Calibration

The motor has a built in differential quadrature encoder with index (as well as hall effects, but those will not be used)

The calibration file only has to be run once, then at start up it will find the index position (in direction of tensioning seatbelt)

It also disables many safety features like torque mode velocity limits, velocity limits, and acceleration limits. If you fix NONE of these, at least fix torque mode velocity limit, because if the belt breaks and the motor is free to apply torque without resistance, it will speed up to its full power very quickly, swinging whatever belt remains on its axis at maximum speed.

#### E-stop
Such a vivacious design requires a safety feature. A button to pull nRST on the Odrive will stop the motor torque and restart the driver.
